<!doctype html> <html> <head> <meta charset=UTF-8 /> <meta http-equiv=Content-Type content="text/html"/> <title>Connecting Apps with the Tailscale Kubernetes Operator - Part 2 - AskTheRelic.com</title> <link rel=alternate type="application/rss+xml" title="RSS 2.0" href="/code/feed.xml"/> <link rel=stylesheet media=screen href="/stylesheets/code.css"/> <link rel=stylesheet href='/stylesheets/github.css'/> <link rel="shortcut icon" href="/favicon.ico"> <script src="https://code.jquery.com/jquery-1.12.4.js" integrity="sha256-Qw82+bXyGq6MydymqBxNPYTaUXXq7c8v3CwiYwLLNXU=" crossorigin=anonymous></script> <script src="https://code.jquery.com/ui/1.8.24/jquery-ui.min.js" integrity="sha256-UOoxwEUqhp5BSFFwqzyo2Qp4JLmYYPTHB8l+1yhZij8=" crossorigin=anonymous></script> </head> <body> <div id=container> <div id=container2> <div id=container1> <div id=left> <div id=left-header> <h2><a href="/code">/code - a blog</a></h2> </div> <div id=content> <div id=main_block> <div id=prose_block class=post> <a name=connecting-apps-with-the-tailscale-kubernetes-operator-part-2 /> <h2 class="blog.post_title"><a href="/2024/07/15/connecting-apps-with-the-tailscale-kubernetes-operator-part-2/">Connecting Apps with the Tailscale Kubernetes Operator - Part 2</a></h2> <small>July 15, 2024 at 01:00 PM</small> <span class=post-prose> <p>In <a href="/2024/02/23/exploring-the-tailscale-kubernetes-operator-part1/">Part 1</a>, I explored installing the Tailscale (TS) K8S operator and adding an Ingress object to make a K8S Service available to the TS network over HTTP.</p> <p>In this post, I want to cover different Egress and Ingress options and ways to connect apps on the TS network.</p> <p>For more context, while I&rsquo;ve been experimenting with kind and a virtual Kubernetes (K8S) cluster, I run a personal server running at home with plenty of resources and a virtual server that hosts my public web apps. Being able to connect the two servers over TS is one of my goals. It allows me to do more permanent and resource intensive things on my personal server, but also make them available publicly when I want.</p> <p>For example: <span class=aligncenter> <img src="/pic/2024-07-15-networks.png" alt=""/> </span></p> <p><strong>Caveat: Under Active Development</strong></p> <p>The TS K8S Operator is under active development and some of these capabilities were add in <a href="https://tailscale.com/changelog#2024-05-15">v1.66</a>. Make sure you are running the latest version. </p> <p>There is even a Helm chart now for easier updating - <a href="https://tailscale.com/kb/1236/kubernetes-operator#helm">https://tailscale.com/kb/1236/kubernetes-operator#helm</a></p> <h3>Exposing TS Apps to your Cluster</h3> <p>To expose existing TS Apps to your K8S cluster, you can use the ExternalName Service, which creates an TS Pod to proxy traffic.</p> <p>For example, to expose the Home Server to K8S, you could create this Service:</p> <div class=highlight><pre class="highlight yaml"><code><span class="nn">---</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Service</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">home-server</span>
  <span class="na">annotations</span><span class="pi">:</span>
    <span class="na">tailscale.com/tailnet-ip</span><span class="pi">:</span> <span class="s2">"</span><span class="s">100.X.X.1"</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">externalName</span><span class="pi">:</span> <span class="s">placeholder</span>
  <span class="na">type</span><span class="pi">:</span> <span class="s">ExternalName</span>
</code></pre></div> <p>Then you would get a K8S Service and could curl <code class=prettyprint>ts-home-server-lmc8s.tailscale.svc.cluster.local</code> within your cluster:</p> <div class=highlight><pre class="highlight shell"><code><span class="nv">$ </span>kubectl get service tower
NAME          TYPE           CLUSTER-IP  EXTERN   
home-server   ExternalName   &lt;none&gt;      ts-home-server-lmc8s.tailscale.svc.cluster.local
</code></pre></div> <h3>Now with TS DNS names</h3> <p>Now with v1.66 of the Operator, using full TS domain names are supported instead of TS IPs, by running a TS managed DNS server. <a href="https://tailscale.com/kb/1236/kubernetes-operator#exposing-a-tailnet-service-to-your-kubernetes-cluster-cluster-egress">Official docs here</a>.</p> <p>First, add the DNS component:</p> <div class=highlight><pre class="highlight yaml"><code><span class="nn">---</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">tailscale.com/v1alpha1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">DNSConfig</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">ts-dns</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">nameserver</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span>
      <span class="na">repo</span><span class="pi">:</span> <span class="s">tailscale/k8s-nameserver</span>
      <span class="na">tag</span><span class="pi">:</span> <span class="s">unstable</span>
</code></pre></div> <p>Then get the Pod IP and add it to your Cluster DNS config. In my K8S setup, I use coredns.</p> <div class=highlight><pre class="highlight shell"><code><span class="nv">$ </span>kubectl get dnsconfig ts-dns <span class="nt">-o</span> json | jq .status.nameserver.ip <span class="nt">-r</span>
10.43.239.128

<span class="nv">$ </span>kubectl edit configmaps <span class="nt">-n</span> kube-system coredns
...
ts.net <span class="o">{</span>
    errors
    cache 30
    forward <span class="nb">.</span> 10.43.239.128
<span class="o">}</span>
...

<span class="nv">$ </span>kubectl rollout restart <span class="nt">-n</span> kube-system deployment coredns
</code></pre></div> <p>Now you can create your Service with a FQDN. And another new feature recently added is the <code class=prettyprint>tailscale.com/hostname</code> annotation, that allows you to name the TS Proxy instead of using a random prefix, to keep things more organized on the TS side.</p> <div class=highlight><pre class="highlight yaml"><code><span class="nn">---</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Service</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">homeserver-fqdn</span>
  <span class="na">annotations</span><span class="pi">:</span>
    <span class="na">tailscale.com/tailnet-fqdn</span><span class="pi">:</span> <span class="s2">"</span><span class="s">homeserver.bee-haka.ts.net"</span>
    <span class="na">tailscale.com/hostname</span><span class="pi">:</span> <span class="s2">"</span><span class="s">homeserver-fqdn"</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">externalName</span><span class="pi">:</span> <span class="s">placeholder</span>
  <span class="na">type</span><span class="pi">:</span> <span class="s">ExternalName</span>
</code></pre></div> <h3>Creating a TS Proxy with Subnet Routes</h3> <p>Another TS feature is subnet routing; sharing entire CIDR routes to TS. </p> <p>In my example, even though I have my Home Server directly shared on TS, I can also get to it via the Apple TV that is sharing the <code class=prettyprint>192.168.1.X/24</code> route. <a href="https://www.youtube.com/watch?v=hYd5etBpsO0">Apple TV subnet routing release here</a>.</p> <p>To create a TS Proxy with subnet routings, one of the other new objects is a ProxyClass, for configuring the TS Proxy:</p> <div class=highlight><pre class="highlight yaml"><code><span class="nn">---</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">tailscale.com/v1alpha1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">ProxyClass</span>
<span class="na">metadata</span><span class="pi">:</span>
    <span class="na">name</span><span class="pi">:</span> <span class="s">acceptroutes</span>
<span class="na">spec</span><span class="pi">:</span>
    <span class="na">tailscale</span><span class="pi">:</span>
        <span class="na">acceptRoutes</span><span class="pi">:</span> <span class="no">true</span>
<span class="nn">---</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Service</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">home-server-via-apple-tv</span>
  <span class="na">labels</span><span class="pi">:</span>
    <span class="na">tailscale.com/proxy-class</span><span class="pi">:</span> <span class="s">acceptroutes</span>
  <span class="na">annotations</span><span class="pi">:</span>
    <span class="na">tailscale.com/tailnet-ip</span><span class="pi">:</span> <span class="s2">"</span><span class="s">192.168.1.1"</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">externalName</span><span class="pi">:</span> <span class="s">placeholder</span>
  <span class="na">type</span><span class="pi">:</span> <span class="s">ExternalName</span>
</code></pre></div> <h3>Expose HTTPS services with TS SSL</h3> <p>Lastly, you can also expose TS Apps with FQDNs and automatically generated LetsEncrypt certs. I believe you could generate and download the certs manually before, this is another convenient primitive for apps that need to know their address.</p> <p>For example, given an existing &ldquo;registry&rdquo; Service, you can expose it with an Ingress and tls params.</p> <div class=highlight><pre class="highlight yaml"><code><span class="nn">---</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">networking.k8s.io/v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Ingress</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">registry</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">defaultBackend</span><span class="pi">:</span>
    <span class="na">service</span><span class="pi">:</span>
      <span class="na">name</span><span class="pi">:</span> <span class="s">registry</span>
      <span class="na">port</span><span class="pi">:</span>
        <span class="na">number</span><span class="pi">:</span> <span class="m">80</span>
  <span class="na">ingressClassName</span><span class="pi">:</span> <span class="s">tailscale</span>
  <span class="na">tls</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">hosts</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="s">registry</span>
</code></pre></div><div class=highlight><pre class="highlight shell"><code><span class="nv">$ </span>kubectl get ingress
NAME       CLASS       HOSTS   ADDRESS                                 PORTS     AGE
nginx      tailscale   <span class="k">*</span>       default-nginx-ingress.bee-hake.ts.net   80        3d3h
registry   tailscale   <span class="k">*</span>       registry.bee-hake.ts.net                80, 443   3d2h
</code></pre></div> <p>So this is the Docker Registry service that I&rsquo;m running, so I can build Docker Images on my Home Server and then use them in K8S. It&rsquo;s more convenient than other ways to push a Docker Image to a central shared point on TS.</p> <p>Overall, these are useful primitives for bi-directional sharing between the TS network and K8S. The TS Operator has made it easier to connect my apps together securely and I&rsquo;ll continue to watch for new capabilties!</p> </span> </div> </div> <div class=hr></div> <div> <h4>Recent Articles</h4> <div class="post frontpage"> <span class=linkdate>15 Jul 2024 »</span> <a href="/2024/07/15/connecting-apps-with-the-tailscale-kubernetes-operator-part-2/">Connecting Apps with the Tailscale Kubernetes Operator - Part 2</a> </div> <div class="post frontpage"> <span class=linkdate>23 Feb 2024 »</span> <a href="/2024/02/23/exploring-the-tailscale-kubernetes-operator-part1/">Exploring the Tailscale Kubernetes Operator - Part 1</a> </div> <div class="post frontpage"> <span class=linkdate>05 Feb 2024 »</span> <a href="/2024/02/05/quarterly-calendar-project/">Quarterly Calendar Project</a> </div> <div class="post frontpage"> <span class=linkdate>05 Jan 2024 »</span> <a href="/2024/01/05/joining-recurse-w2-2024/">Joining Recurse Center for W2 2024</a> </div> <div class="post frontpage"> <span class=linkdate>08 Jan 2017 »</span> <a href="/2017/01/08/hosting-with-dokku/">Hosting with Dokku</a> </div> <div class="post frontpage"> <span class=linkdate>18 Sep 2016 »</span> <a href="/2016/09/18/testing-the-layers-of-your-application-at-pyconuk-2016/">Testing the Layers of Your Application at PyConUK 2016</a> </div> <div class="post frontpage"> <span class=linkdate>21 Apr 2014 »</span> <a href="/2014/04/21/upgrading-my-dotfiles-to-symlinks/">Upgrading My Dotfiles To Symlinks</a> </div> </div> </div> <div class=hr></div> <p id=credits> Powered by <a href="https://middlemanapp.com/">Middleman</a>. <br/> <br/> </p> </div> <div id=right> <div id=right-header> <a href="/"><h1>Ask the Relic</h1></a> </div> </div> </div> </div> </div> </body> </html>